# Бинарный поиск

Левый бинарный поиск позволяет найти <br>
первое (наиболее левое) вхождение элемента в массиве.

Идея хорошего левого бинарного поиска ([отсюда](https://sis.khashaev.ru/2013/july/b-prime/5rDJtGs58Zg/)).

Будем поддерживать __инвариант__ `a[left] < key <= a[right]`, <br>
и искать элемент не на отрезке `[left; right]`, а на полуинтервале `(left; right]`.

Начальные условия.

1) left = -1 и a[-1] = бесконечно маленькое число, <br>
таким образом соблюдается условие a[left] < key, <br>
при этом нам не обязательно иметь элемент с индексом -1. <br>
Т.е мы для себя можем считать что он есть, <br>
но к нему обращаться не придется.

2) right = индекс последнего элемента (length - 1)

В условии цикла пишем не `left != right`, <br>
так как это код рискует зациклиться, а `right - left > 1`.

В цикле важно понять как изменять границы, чтобы сохранить инвариант.

Естественно сначала надо найти индекс среднего элемента. <br>
Чаще всего пишут что-то в стиле `mid = (left + right) div 2`. <br>
(здесь div - целочисленное деление, в C / C++ это `/`, в Python это `//` и.т.д) <br>
Но это не очень хороший способ:<br>
`(left + right)` может быть
больше максимально возможного числа (т.е больше MAX_INT какого-то), <br>
и в тоже время `(left + right) div 2` будет в пределах числового типа (т.е меньше MAX_INT). <br>
Потому лучше писать `mid = left + (right - left) div 2`. <br>
`(right - left)` влезает в тип, если `right` и `left` влезли,
половина их суммы тем более.

1) Если key > a[mid], тогда мы можем подвинуть левую границу,
т.е присвоить left значение mid(без всяких +-1) и тогда a[left] < key
все еще выполняется.

2) Если key < a[mid], тогда мы можем подвинуть правую границу,
т.е присвоить right значение mid(без всяких +-1) и тогда key <= a[right]
все еще выполняется.

3) Если же key = a[mid], то мы можем подвинуть правую границу,
она сдвинется влево(right = mid, инвариант соблюдается), 
и за счет этого будет находится именно левое вхождение,
так как при наличии нескольких равных элементов,
будем двигаться влево, чтобы найти самый первый.

Можно заметить что случаи 2 и 3 легко объединить,
т.е если key <= a[mid], тогда mid присвоим right.

После цикла у нас остаются left, right. <br>
Инвариант все еще `a[left] < key <= a[right]`, <br>
1) `a[left]` совсем не подходит <br>
(и как раз не нужно думать о том, <br>
 как обращаться к элементу с индексом -1, если left = -1),
2) Может подойти только `a[right]`, но мы знаем,
что `key <= a[right]`. <br>
Значит надо проверить на точное равенство `key` и `a[right]` и только в этом случае
элемент найден.

Реализация на JavaScript

```javascript
function leftSearch(a, key) {
  if (a.length === 0)
    return -1;

  // a[left] < key <= a[right]
  let left = -1;
  let right = a.length - 1;
    
  while (right - left > 1) {
    let len = Math.floor((right - left) / 2)
    let mid = left + len;
    if (key > a[mid]) left = mid;
    else right = mid;
  }
    
  return a[right] === key ? right : -1;
}

//           0   1   2   3   4   5   6   7   8   9   10
const arr = [11, 15, 15, 23, 24, 24, 24, 25, 26, 26, 26];

console.log(leftSearch(arr, 10));
console.log(leftSearch(arr, 11));
console.log(leftSearch(arr, 15));
console.log(leftSearch(arr, 20));
console.log(leftSearch(arr, 24));
console.log(leftSearch(arr, 26));

```

Чтобы реализовать правый бинарный поиск,
можно использовать такую же идею.

Но теперь инвариант <br>
`a[left] <= key < a[right]` <br> 
и границы <br>
`left = 0` <br>
`right = length`

Естественное считаем, что в `a[right]` бесконечно большое число, <br>
и опять же к этому элементу обращаться не придется.

left двигаем вправо если key >= a[mid], <br>
right двигаем влево если key < a[mid]

Реализация на JavaScript примерно такая

```javascript
function rightSearch(a, key) {
  if (a.length === 0)
    return -1;

  // a[left] <= key < a[right]
  let left = 0;
  let right = a.length;
    
  while (right - left > 1) {
    let len = Math.floor((right - left) / 2)
    let mid = left + len;
    if (key < a[mid]) right = mid;
    else left = mid;
  }
    
  return a[left] === key ? left : -1;
}
```
